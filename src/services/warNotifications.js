const cron = require('node-cron');
const { escapeHtml, parseApiDate } = require('../utils/helpers');
const clan = require('../callbacks/clan');

class WarNotificationService {
    constructor(clashOfClansClient, bot, chatId, database) {
        this.clashOfClansClient = clashOfClansClient;
        this.bot = bot;
        this.chatId = chatId; // Bildirimlerin g√∂nderileceƒüi grup/kanal ID'si
        this.database = database; // Veritabanƒ± referansƒ±
        this.notificationState = {
            lastWarState: null,
            notificationsSent: {
                warFound: false,
                fifteenMinutesStart: false, // Tek ba≈ülangƒ±√ß bildirimi - 15 dakika
                warStarted: false,
                oneHourEnd: false,
                thirtyMinutesEnd: false,
                fiveMinutesEnd: false,
                warEnded: false
            },
            lastWarEndTime: null,
            currentWarId: null // Benzersiz sava≈ü ID'si
        };
        this.isRunning = false;
        this.apiErrorCount = 0; // API hata sayacƒ±
        this.maxApiErrors = 3; // Maksimum ardƒ±≈üƒ±k hata sayƒ±sƒ±
    }

    // Benzersiz sava≈ü ID'si olu≈ütur
    generateWarId(response) {
        if (!response.preparationStartTime) return null;
        
        // preparationStartTime + opponent tag kombinasyonu
        const opponentTag = response.opponent?.tag || 'unknown';
        const teamSize = response.teamSize || 0;
        return `${response.preparationStartTime}_${opponentTag}_${teamSize}`;
    }

    // Bildirim sistemi ba≈ülat
    start() {
        if (this.isRunning) {
            return;
        }
        
        // Her 3 dakikada bir kontrol et (API limitlerini korumak i√ßin)
        this.cronJob = cron.schedule('*/3 * * * *', async () => {
            await this.checkWarStatus();
        }, {
            scheduled: false
        });

        this.cronJob.start();
        this.isRunning = true;
        console.log('üîî Bildirim sistemi ba≈ülatƒ±ldƒ± (3 dakika aralƒ±kla)');
    }

    // Bildirim sistemi durdur
    stop() {
        if (this.cronJob) {
            this.cronJob.stop();
            this.isRunning = false;
            console.log('üîï Bildirim sistemi durduruldu');
        }
    }

    // Sava≈ü durumunu kontrol et
    async checkWarStatus() {
        try {
            const clanTag = await this.database.getConfig('clan_tag');
            if (!clanTag) {
                console.error('‚ùå Klan tag\'i yapƒ±landƒ±rƒ±lmamƒ±≈ü');
                return;
            }

            const response = await this.clashOfClansClient.clanCurrentWarByTag(clanTag);
            const clanName = await clan.getClanName(this.clashOfClansClient);
            
            // API √ßaƒürƒ±sƒ± ba≈üarƒ±lƒ±, hata sayacƒ±nƒ± sƒ±fƒ±rla
            this.apiErrorCount = 0;
            
            // Yeni sava≈ü mƒ± kontrol et
            const currentWarId = this.generateWarId(response);
            if (currentWarId && currentWarId !== this.notificationState.currentWarId) {
                console.log(`üÜï Yeni sava≈ü tespit edildi: ${currentWarId}`);
                // √ñnce state'i temizle
                this.resetNotificationState();
                this.notificationState.lastWarState = null;
                // Sonra yeni war ID'yi set et
                this.notificationState.currentWarId = currentWarId;
                // Son olarak notification history'yi y√ºkle
                await this.loadNotificationHistory(currentWarId);
                console.log('üîÑ Yeni sava≈ü i√ßin state temizlendi');
            }
            
            // Sava≈ü durumu deƒüi≈üti mi kontrol et
            if (response.state !== this.notificationState.lastWarState) {
                console.log(`üîÑ Sava≈ü durumu deƒüi≈üti: ${this.notificationState.lastWarState} -> ${response.state}`);
                await this.handleStateChange(response, clanName);
            }

            // Sava≈üta ise zaman kontrol√º yap
            if (response.state === 'preparation' || response.state === 'inWar') {
                await this.handleWarTimeChecks(response, clanName);
            }

            // Sava≈ü bittiyse state'i g√ºncelle
            if (response.state === 'warEnded' && this.notificationState.lastWarState !== 'warEnded') {
                console.log('üèÅ Sava≈ü sona erdi');
            }

            this.notificationState.lastWarState = response.state;

        } catch (error) {
            this.apiErrorCount++;
            console.error(`‚ùå Sava≈ü durumu kontrol√ºnde hata (${this.apiErrorCount}/${this.maxApiErrors}):`, error.message);
            
            // √áok fazla hata varsa sistemi ge√ßici olarak durdur
            if (this.apiErrorCount >= this.maxApiErrors) {
                console.error('üö® √áok fazla API hatasƒ±, bildirim sistemi ge√ßici olarak durduruluyor...');
                setTimeout(() => {
                    this.apiErrorCount = 0;
                    console.log('üîÑ API hata sayacƒ± sƒ±fƒ±rlandƒ±, sistem normal √ßalƒ±≈ümaya devam ediyor');
                }, 300000); // 5 dakika bekle
            }
        }
    }

    // Bildirim ge√ßmi≈üini y√ºkle
    async loadNotificationHistory(warId) {
        try {
            // G√ºncellenmi≈ü bildirim tiplerini kontrol et
            const notificationTypes = [
                'warFound', 'fifteenMinutesStart', 'warStarted', 
                'oneHourEnd', 'thirtyMinutesEnd', 'fiveMinutesEnd', 'warEnded'
            ];

            for (const notificationType of notificationTypes) {
                const sent = await this.database.hasNotificationSent(notificationType, warId);
                this.notificationState.notificationsSent[notificationType] = sent;
            }

            console.log(`üìã Bildirim ge√ßmi≈üi y√ºklendi: ${warId}`);
        } catch (error) {
            console.error('‚ùå Bildirim ge√ßmi≈üi y√ºklenirken hata:', error);
        }
    }

    // Durum deƒüi≈üikliƒüi i≈üle
    async handleStateChange(response, clanName) {
        const safeOpponentName = escapeHtml(response.opponent?.name || 'Bilinmeyen Rakip');
        
        switch (response.state) {
            case 'preparation':
                if (!this.notificationState.notificationsSent.warFound) {
                    const message = this.createWarFoundMessage(response, clanName, safeOpponentName);
                    await this.sendNotification(message, 'warFound', this.notificationState.currentWarId);
                    this.notificationState.notificationsSent.warFound = true;
                }
                break;
                
            case 'inWar':
                if (!this.notificationState.notificationsSent.warStarted) {
                    const message = this.createWarStartedMessage(response, clanName, safeOpponentName);
                    await this.sendNotification(message, 'warStarted', this.notificationState.currentWarId);
                    this.notificationState.notificationsSent.warStarted = true;
                }
                break;
                
            case 'warEnded':
                if (!this.notificationState.notificationsSent.warEnded) {
                    const message = this.createWarEndedMessage(response, clanName, safeOpponentName);
                    await this.sendNotification(message, 'warEnded', this.notificationState.currentWarId);
                    this.notificationState.notificationsSent.warEnded = true;
                }
                break;
        }
    }

    // Zaman kontrollerini i≈üle
    async handleWarTimeChecks(response, clanName) {
        const safeOpponentName = escapeHtml(response.opponent?.name || 'Bilinmeyen Rakip');
        
        // Sava≈ü ba≈ülangƒ±√ß zamanƒ± kontrol√º (preparation a≈üamasƒ±nda) - Sadece 15 dakika
        if (response.state === 'preparation' && response.startTime) {
            await this.checkStartTimeWarning(
                response, 
                clanName, 
                safeOpponentName, 
                response.startTime
            );
        }
        
        // Sava≈ü biti≈ü zamanƒ± kontrol√º (inWar a≈üamasƒ±nda) - Saldƒ±rƒ± yapmayanlarla
        if (response.state === 'inWar' && response.endTime) {
            await this.checkEndTimeWarnings(
                response, 
                clanName, 
                safeOpponentName, 
                response.endTime
            );
        }
    }

    // Sava≈ü ba≈ülangƒ±√ß zaman uyarƒ±sƒ± (sadece 15 dakika)
    async checkStartTimeWarning(response, clanName, opponentName, targetTimeString) {
        const targetTime = parseApiDate(targetTimeString);
        if (!targetTime || isNaN(targetTime.getTime())) {
            console.warn('‚ö†Ô∏è Ge√ßersiz tarih formatƒ±:', targetTimeString);
            return;
        }

        const now = new Date();
        const timeDiff = targetTime.getTime() - now.getTime();
        const minutesLeft = Math.floor(timeDiff / (1000 * 60));

        // Negatif s√ºre kontrol√º
        if (minutesLeft < 0) return;

        // 12-18 dakika arasƒ± (15 dakika bildirimi)
        if (minutesLeft >= 12 && minutesLeft <= 18 && !this.notificationState.notificationsSent.fifteenMinutesStart) {
            const message = this.createStartTimeWarningMessage(response, clanName, opponentName, minutesLeft);
            await this.sendNotification(message, 'fifteenMinutesStart', this.notificationState.currentWarId);
            this.notificationState.notificationsSent.fifteenMinutesStart = true;
            console.log(`‚è∞ 15 dakika ba≈ülangƒ±√ß bildirimi g√∂nderildi (${minutesLeft} dakika kaldƒ±)`);
        }
    }

    // Sava≈ü biti≈ü zaman uyarƒ±larƒ± (saldƒ±rƒ± yapmayanlarla)
    async checkEndTimeWarnings(response, clanName, opponentName, targetTimeString) {
        const targetTime = parseApiDate(targetTimeString);
        if (!targetTime || isNaN(targetTime.getTime())) {
            console.warn('‚ö†Ô∏è Ge√ßersiz tarih formatƒ±:', targetTimeString);
            return;
        }

        const now = new Date();
        const timeDiff = targetTime.getTime() - now.getTime();
        const minutesLeft = Math.floor(timeDiff / (1000 * 60));

        // Negatif s√ºre kontrol√º
        if (minutesLeft < 0) return;

        // 45-75 dakika arasƒ± (1 saat bildirim)
        if (minutesLeft >= 45 && minutesLeft <= 75 && !this.notificationState.notificationsSent.oneHourEnd) {
            const message = await this.createEndTimeWarningMessage(response, clanName, opponentName, minutesLeft);
            await this.sendNotification(message, 'oneHourEnd', this.notificationState.currentWarId);
            this.notificationState.notificationsSent.oneHourEnd = true;
            console.log(`‚è∞ 1 saat biti≈ü bildirimi g√∂nderildi (${minutesLeft} dakika kaldƒ±)`);
        }

        // 25-35 dakika arasƒ± (30 dakika bildirim)
        if (minutesLeft >= 25 && minutesLeft <= 35 && !this.notificationState.notificationsSent.thirtyMinutesEnd) {
            const message = await this.createEndTimeWarningMessage(response, clanName, opponentName, minutesLeft);
            await this.sendNotification(message, 'thirtyMinutesEnd', this.notificationState.currentWarId);
            this.notificationState.notificationsSent.thirtyMinutesEnd = true;
            console.log(`‚è∞ 30 dakika biti≈ü bildirimi g√∂nderildi (${minutesLeft} dakika kaldƒ±)`);
        }

        // 3-7 dakika arasƒ± (5 dakika bildirim)
        if (minutesLeft >= 3 && minutesLeft <= 7 && !this.notificationState.notificationsSent.fiveMinutesEnd) {
            const message = await this.createEndTimeWarningMessage(response, clanName, opponentName, minutesLeft);
            await this.sendNotification(message, 'fiveMinutesEnd', this.notificationState.currentWarId);
            this.notificationState.notificationsSent.fiveMinutesEnd = true;
            console.log(`‚è∞ 5 dakika biti≈ü bildirimi g√∂nderildi (${minutesLeft} dakika kaldƒ±)`);
        }
    }

    // Saldƒ±rƒ± yapmayan oyuncularƒ± bul
    async getNonAttackers(warResponse) {
        try {
            if (!warResponse.clan || !warResponse.clan.members) {
                return [];
            }

            const nonAttackers = [];
            const totalAttacksPerMember = warResponse.attacksPerMember || 2;

            for (const member of warResponse.clan.members) {
                const attackCount = member.attacks ? member.attacks.length : 0;
                
                if (attackCount < totalAttacksPerMember) {
                    // Doƒürulanmƒ±≈ü kullanƒ±cƒ± bilgisini al
                    const verifiedUser = await this.database.getVerifiedUserByPlayerTag(member.tag);
                    
                    nonAttackers.push({
                        name: member.name,
                        tag: member.tag,
                        mapPosition: member.mapPosition,
                        attacksUsed: attackCount,
                        attacksRemaining: totalAttacksPerMember - attackCount,
                        telegramUser: verifiedUser || null
                    });
                }
            }

            // Map pozisyonuna g√∂re sƒ±rala
            nonAttackers.sort((a, b) => a.mapPosition - b.mapPosition);
            return nonAttackers;

        } catch (error) {
            console.error('‚ùå Saldƒ±rƒ± yapmayan oyuncularƒ± alƒ±rken hata:', error);
            return [];
        }
    }

    // Sava≈ü ba≈ülangƒ±√ß zaman uyarƒ± mesajƒ± (15 dakika)
    createStartTimeWarningMessage(response, clanName, opponentName, minutesLeft) {
        return `‚ö†Ô∏è **SAVA≈û ${this.formatTimeLeft(minutesLeft).toUpperCase()} SONRA BA≈ûLIYOR!** ‚ö†Ô∏è

üè∞ **${clanName}** vs **${opponentName}**

üìä **Mevcut Durum:**
üîµ Takƒ±m B√ºy√ºkl√ºƒü√º: ${response.teamSize} vs ${response.teamSize}
üèÜ Bizim yƒ±ldƒ±z: ${response.clan?.stars || 0}
‚≠ê Rakip yƒ±ldƒ±z: ${response.opponent?.stars || 0}

‚öîÔ∏è **Hazƒ±rlƒ±klarƒ±nƒ±zƒ± tamamlayƒ±n!**
üí° Saldƒ±rƒ± planlarƒ±nƒ±zƒ± yapƒ±n ve savunma stratejilerinizi g√∂zden ge√ßirin!`;
    }

    // Sava≈ü biti≈ü zaman uyarƒ± mesajƒ± (saldƒ±rƒ± yapmayanlarla)
    async createEndTimeWarningMessage(response, clanName, opponentName, minutesLeft) {
        const warningIcon = minutesLeft <= 5 ? 'üö®' : minutesLeft <= 30 ? '‚ö†Ô∏è' : '‚è∞';
        const urgencyText = minutesLeft <= 5 ? 'SON' : '';
        
        let message = `${warningIcon} **SAVA≈û ${urgencyText} ${this.formatTimeLeft(minutesLeft).toUpperCase()} SONRA Bƒ∞Tƒ∞YOR!** ${warningIcon}

üè∞ **${clanName}** vs **${opponentName}**

üìä **Mevcut Durum:**
üèÜ Bizim yƒ±ldƒ±z: ${response.clan?.stars || 0}
‚≠ê Rakip yƒ±ldƒ±z: ${response.opponent?.stars || 0}
üí• Bizim saldƒ±rƒ±: ${response.clan?.attacks || 0}/${response.attacksPerMember * response.teamSize}
üõ°Ô∏è Rakip saldƒ±rƒ±: ${response.opponent?.attacks || 0}/${response.attacksPerMember * response.teamSize}`;

        // Saldƒ±rƒ± yapmayanlarƒ± ekle
        const nonAttackers = await this.getNonAttackers(response);
        
        if (nonAttackers.length > 0) {
            message += `\n\nüö® **SALDIRI YAPMAYAN √úYELERƒ∞Mƒ∞Z** (${nonAttackers.length} ki≈üi):`;
            
            let verifiedCount = 0;
            let unverifiedCount = 0;
            
            for (const member of nonAttackers.slice(0, 15)) { // ƒ∞lk 15 ki≈üi (mesaj limiti i√ßin)
                const positionText = `#${member.mapPosition}`;
                const attackText = `${member.attacksUsed}/${member.attacksUsed + member.attacksRemaining}`;
                
                if (member.telegramUser) {
                    const telegramName = member.telegramUser.telegram_first_name || 'Bilinmeyen';
                    const username = member.telegramUser.telegram_username ? `@${member.telegramUser.telegram_username}` : '';
                    message += `\n${positionText} ${member.name} (${attackText}) - ${telegramName} ${username}`;
                    verifiedCount++;
                } else {
                    message += `\n${positionText} ${member.name} (${attackText}) - ‚ùå Doƒürulanmamƒ±≈ü`;
                    unverifiedCount++;
                }
            }
            
            if (nonAttackers.length > 15) {
                message += `\n... ve ${nonAttackers.length - 15} ki≈üi daha`;
            }
            
            message += `\n\nüìä **√ñzet:** ‚úÖ ${verifiedCount} doƒürulanmƒ±≈ü, ‚ùå ${unverifiedCount} doƒürulanmamƒ±≈ü`;
        } else {
            message += `\n\nüéâ **T√úM √úYELERƒ∞Mƒ∞Z SALDIRDI!** üéâ`;
        }

        message += `\n\nüî• **${minutesLeft <= 5 ? 'SON DAKƒ∞KA!' : 'HALA VAKIT VAR!'} Son saldƒ±rƒ±larƒ±nƒ±zƒ± yapƒ±n!**`;
        
        return message;
    }

    // Kalan s√ºreyi formatla
    formatTimeLeft(minutes) {
        if (minutes <= 0) return 'S√ºre doldu';
        
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;
        
        if (hours > 0) {
            if (remainingMinutes > 0) {
                return `${hours} saat ${remainingMinutes} dakika`;
            } else {
                return `${hours} saat`;
            }
        } else {
            return `${remainingMinutes} dakika`;
        }
    }

    // Sava≈ü bulundu mesajƒ± - sadele≈ütirildi
    createWarFoundMessage(response, clanName, opponentName) {
        const startDate = parseApiDate(response.startTime);
        
        let timeLeftMessage = '';
        if (startDate) {
            const now = new Date();
            const timeDiff = startDate.getTime() - now.getTime();
            const minutesLeft = Math.floor(timeDiff / (1000 * 60));
            if (minutesLeft > 0) {
                timeLeftMessage = `‚è∞ ${this.formatTimeLeft(minutesLeft)} sonra ba≈ülayacak`;
            }
        }
        
        return `üö® **SAVA≈û BULUNDU!** üö®

üè∞ **${clanName}** vs **${opponentName}**

üìä **Detaylar:**
üîµ Bizim takƒ±m: ${response.teamSize} vs ${response.teamSize}
üèÜ Bizim yƒ±ldƒ±z: ${response.clan?.stars || 0}
‚≠ê Rakip yƒ±ldƒ±z: ${response.opponent?.stars || 0}

${timeLeftMessage}

üí™ Hadi bakalƒ±m, sava≈üa hazƒ±rlanƒ±n! üó°Ô∏è`;
    }

    // Sava≈ü ba≈üladƒ± mesajƒ±
    createWarStartedMessage(response, clanName, opponentName) {
        const endDate = parseApiDate(response.endTime);
        
        let timeLeftMessage = '';
        if (endDate) {
            const now = new Date();
            const timeDiff = endDate.getTime() - now.getTime();
            const minutesLeft = Math.floor(timeDiff / (1000 * 60));
            if (minutesLeft > 0) {
                timeLeftMessage = `‚è∞ ${this.formatTimeLeft(minutesLeft)} s√ºreniz var!`;
            }
        }

        return `‚öîÔ∏è **SAVA≈û BA≈ûLADI!** ‚öîÔ∏è

üè∞ **${clanName}** vs **${opponentName}**

üìä **Mevcut Durum:**
üèÜ Bizim yƒ±ldƒ±z: ${response.clan?.stars || 0}
‚≠ê Rakip yƒ±ldƒ±z: ${response.opponent?.stars || 0}
üí• Bizim saldƒ±rƒ±: ${response.clan?.attacks || 0}/${response.attacksPerMember * response.teamSize}
üõ°Ô∏è Rakip saldƒ±rƒ±: ${response.opponent?.attacks || 0}/${response.attacksPerMember * response.teamSize}

${timeLeftMessage}

üî• Saldƒ±rƒ±larƒ±nƒ±zƒ± yapƒ±n! Klan i√ßin! üí™`;
    }

    // Sava≈ü bitti mesajƒ±
    createWarEndedMessage(response, clanName, opponentName) {
        const result = this.getWarResult(response);
        
        return `üèÅ **SAVA≈û Bƒ∞TTƒ∞!** üèÅ

üè∞ **${clanName}** vs **${opponentName}**

üìä **Final Sonu√ßlarƒ±:**
üèÜ Bizim yƒ±ldƒ±z: ${response.clan?.stars || 0}
‚≠ê Rakip yƒ±ldƒ±z: ${response.opponent?.stars || 0}
üí• Bizim saldƒ±rƒ±: ${response.clan?.attacks || 0}/${response.attacksPerMember * response.teamSize}
üõ°Ô∏è Rakip saldƒ±rƒ±: ${response.opponent?.attacks || 0}/${response.attacksPerMember * response.teamSize}
üí∞ Hasar: ${response.clan?.destructionPercentage || 0}% vs ${response.opponent?.destructionPercentage || 0}%

${result.icon} **${result.text}**

${result.isWin ? 'üéâ Tebrikler! Harika sava≈ü!' : 'üí™ Bir sonrakinde daha iyisini yapacaƒüƒ±z!'}`;
    }

    // Sava≈ü sonucunu belirle
    getWarResult(response) {
        const ourStars = response.clan?.stars || 0;
        const theirStars = response.opponent?.stars || 0;
        
        if (ourStars > theirStars) {
            return { icon: 'üèÜ', text: 'ZAFER!', isWin: true };
        } else if (ourStars < theirStars) {
            return { icon: 'üòî', text: 'Maƒülubiyet', isWin: false };
        } else {
            return { icon: 'ü§ù', text: 'Beraberlik', isWin: false };
        }
    }

    // Bildirim g√∂nder ve veritabanƒ±na kaydet
    async sendNotification(message, notificationType, warId) {
        try {
            await this.bot.telegram.sendMessage(this.chatId, message, { parse_mode: 'Markdown' });
            
            // Veritabanƒ±na kaydet
            if (this.database && notificationType && warId) {
                await this.database.addNotificationHistory(notificationType, warId, message, this.chatId);
            }
            
            console.log(`‚úÖ Bildirim g√∂nderildi: ${notificationType || 'Bilinmeyen'}`);
        } catch (error) {
            console.error('‚ùå Bildirim g√∂nderim hatasƒ±:', error.message);
        }
    }

    // Bildirim durumlarƒ±nƒ± sƒ±fƒ±rla
    resetNotificationState() {
        this.notificationState.notificationsSent = {
            warFound: false,
            fifteenMinutesStart: false, // G√ºncellenmi≈ü bildirim t√ºrleri
            warStarted: false,
            oneHourEnd: false,
            thirtyMinutesEnd: false,
            fiveMinutesEnd: false,
            warEnded: false
        };
    }

    // Durum bilgisi al
    getStatus() {
        return {
            isRunning: this.isRunning,
            lastWarState: this.notificationState.lastWarState,
            notificationsSent: { ...this.notificationState.notificationsSent },
            currentWarId: this.notificationState.currentWarId,
            chatId: this.chatId
        };
    }

    // Test bildirimi g√∂nder
    async sendTestNotification() {
        try {
            const testMessage = `üß™ **TEST Bƒ∞LDƒ∞Rƒ∞Mƒ∞** üß™

üîî Bildirim sistemi √ßalƒ±≈üƒ±yor!

üìä **Sistem Durumu:**
‚ö° Durum: ${this.isRunning ? 'Aktif' : 'Pasif'}
üÜî Chat ID: ${this.chatId}
üïê Test Zamanƒ±: ${new Date().toLocaleString('tr-TR')}
üîÑ API Hata Sayƒ±sƒ±: ${this.apiErrorCount}/${this.maxApiErrors}

‚úÖ Eƒüer bu mesajƒ± g√∂rebiliyorsanƒ±z, bildirim sistemi d√ºzg√ºn √ßalƒ±≈üƒ±yor!`;

            await this.bot.telegram.sendMessage(this.chatId, testMessage, { parse_mode: 'Markdown' });
            console.log('‚úÖ Test bildirimi ba≈üarƒ±yla g√∂nderildi');
            return true;
        } catch (error) {
            console.error('‚ùå Test bildirimi g√∂nderilirken hata:', error.message);
            return false;
        }
    }

    // Detaylƒ± sistem durumu
    getDetailedStatus() {
        return {
            isRunning: this.isRunning,
            apiErrorCount: this.apiErrorCount,
            maxApiErrors: this.maxApiErrors,
            lastWarState: this.notificationState.lastWarState,
            currentWarId: this.notificationState.currentWarId,
            notificationsSent: { ...this.notificationState.notificationsSent },
            chatId: this.chatId,
            cronSchedule: '*/3 * * * *', // Her 3 dakika
            lastCheck: new Date().toLocaleString('tr-TR')
        };
    }

    // Bildirim sistemini manuel olarak tetikle (debug i√ßin)
    async forceCheck() {
        console.log('üîß Manuel sava≈ü durumu kontrol√º ba≈ülatƒ±lƒ±yor...');
        await this.checkWarStatus();
        console.log('üîß Manuel kontrol tamamlandƒ±');
    }
}

module.exports = WarNotificationService; 